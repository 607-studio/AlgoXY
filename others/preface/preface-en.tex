\ifx\wholebook\relax \else
% ------------------------

\documentclass{article}

%\input{../../../common.tex}
\input{../../common-en.tex}

\setcounter{page}{1}

\begin{document}

%--------------------------

% ================================================================
%                 COVER PAGE
% ================================================================

\title{Preface}

\author{Larry~LIU~Xinyu
\thanks{{\bfseries Larry LIU Xinyu } \newline
  Email: liuxinyu95@gmail.com \newline}
  }

\maketitle
\fi

\markboth{Preface}{Elementary Algorithms}

% ================================================================
%                 Why
% ================================================================
\section{Why?}
\label{why}

`Are algorithms useful?'. Some programmers
say that they seldom use any serious data structures or algorithms
in real work such as commercial application development. Even when they need
some of them, they have already been provided by libraries. For example,
the JDK provides sort and search algorithms as well as the array, list, queue, and set data structures.
It seems that knowing about how to use the library as a tool is quite
enough.

Algorithms and data structures are critical in solving `interesting
problems', the usefulness of the problem set aside. Let's start with two examples.

% ================================================================
%      Mininum free ID problem. The power of algorithms
% ================================================================
\section{The smallest free number problem, the power of algorithms}
\label{min-free} \index{minimum free number}

This problem is discussed in Chapter 1 of Richard Bird's book \cite{fp-book}.
It's common to manage entities with numeric identifiers.
At any time, some numbers are used, while the rest are available for use.
When a client tries to acquire a new identifier, we want to always allocate
it the smallest available one. Suppose identifiers are non-negative integers
and all identifiers in use are kept in a list which is not ordered. For example:


$\{18, 4, 8, 9, 16, 1, 14, 7, 19, 3, 0, 5, 2, 11, 6\}$


How can we find the smallest free number, which is 10, from the list?

It seems the solution is quite straightforward.

\begin{algorithmic}[1]
\Function{Min-Free}{$A$}
  \State $x \gets 0$
  \Loop
    \If{$x \notin A$}
      \State \Return $x$
    \Else
      \State $x \gets x + 1$
    \EndIf
  \EndLoop
\EndFunction
\end{algorithmic}

Where the $\notin$ is realized like below.

\begin{algorithmic}[1]
\Function{`$\notin$'}{$x, X$}
  \For{$i \gets 1 $ to $|X|$}
    \If{$x = X[i]$}
      \State \Return False
    \EndIf
  \EndFor
  \State \Return True
\EndFunction
\end{algorithmic}

Below example in Java demonstrates this idea.

\lstset{language=Java}
\begin{lstlisting}
int findMinFree(int[] nums) {
    int i;
    for(i = 0; contains(i, nums); i++) {}
    return i;
}

boolean contains(int x, int[] nums) {
    for (int n : nums)
        if (x == n) return true;
    return false;
}
\end{lstlisting}

It seems this problem is trivial. However, There will be millions of
identifiers in a large system. The speed of this solution is poor to handle long list as it takes $O(n^2)$ time, where $n$ is the length of the list.
In my computer (2 Cores 2.10 GHz, with 2G RAM), a C program using this
solution takes an average of 5.4~seconds to search among 100,000 numbers.
And it takes more than 8~minutes to handle a million numbers.

\subsection{Improvement 1}
The key idea to improve the solution is based on a fact that for a
series of $n$ numbers $x_1, x_2, ..., x_n$, if there are free numbers,
some of the $x_i$ are outside the range $[0, n)$; otherwise the list is
exactly a permutation of $0, 1, ..., n-1$ and $n$ should be
returned as the answer. We have the following fact.

\be
minfree(x_1, x_2, ..., x_n) \leq n
\label{min-free}
\ee

One solution is to use an array of $n+1$ flags to mark whether a number
in range $[0, n]$ is free.

\begin{algorithmic}[1]
\Function{Min-Free}{$A$}
  \State $F \gets [False, False, ..., False]$ where $|F| = n+1$
  \For{$\forall x \in A$}
    \If{$x < n$}
      \State $F[x] \gets$ True
    \EndIf
  \EndFor
  \For{$i \gets [0, n]$}
    \If{$F[i] =$ False}
      \State \Return $i$
    \EndIf
  \EndFor
\EndFunction
\end{algorithmic}

Line 2 initializes a flag array all of False values. This takes
$O(n)$ time. Then the algorithm scans all numbers in $A$ and mark
the relative flag to True if the value is less than $n$, This
step also takes $O(n)$ time. Finally, the algorithm performs a
linear time search to find the first flag with False value.
So the total performance of this algorithm is $O(n)$. Note that
we use $n+1$ flags instead of $n$ flags to cover the special case
that $sorted(A) = [0, 1, 2, ..., n-1]$.

Although the algorithm only takes $O(n)$ time, it needs extra
$O(n)$ spaces to store the flags.

This solution is much faster than the brute force one. On my
computer, the relevant program takes
an average of 0.02 second when dealing with 100,000 numbers.

We haven't fine tuned this algorithm yet. Observe that each time
we have to allocate memory to create a $n+1$ elements array of
flags, and release the memory when finished.
The memory allocation and release is very
expensive thus they cost us a lot of processing time.

There are two ways in which we can improve on
this solution. One is to allocate the flags array in advance
and reuse it for all the furthur searches.
The other is to use bit-wise flags instead of an array.
Below example in Java illustrates these two minor chagnes.

\lstset{language = Java}
\begin{lstlisting}
final static int N = 1000000;

final BitSet FLAGS = new BitSet(N);

int findMinFree(int[] nums) {
    int i;
    FLAGS.clear();
    for (int x : nums)
        if (x <= nums.length)
            FLAGS.set(x);
    for (i = 0; i < nums.length && FLAGS.get(i); i++) {}
    return i;
}
\end{lstlisting}

This program can find the answer from 1 million numbers in just 0.023 second
on my computer.

\subsection{Improvement 2, Divide and Conquer}
Although the above improvement is much faster, it costs $O(n)$ extra
spaces to keep a flag list. if $n$ is big this means
a large amount of space is wasted.

The typical divide and conquer strategy is to break the problem
into some smaller ones, and solve these to get the final answer.

We can put all numbers $x_i \leq \lfloor n/2 \rfloor$ as a sub-list $A'$ and put all the others as
a second sub-list $A''$. Based on formula (\ref{min-free}) if the length of $A'$ is exactly $\lfloor n/2 \rfloor$, this means
the first half of numbers are `full', which indicates that the
minimum free number must be in $A''$ and so we'll need to recursively seek
in the shorter list $A''$. Otherwise, it means the answer is located in $A'$, which again leads to a smaller problem.

When we search the minimum free number in $A''$, the conditions changes
a little bit, we are not searching the smallest free number starting from
$0$, but actually from $\lfloor n/2 \rfloor + 1$ as the lower bound.
So the algorithm is something like $minfree(A, l, u)$, where $l$ is
the lower bound and $u$ is the upper bound index of the element.

There is a trivial case. If the list is empty, we merely return the lower bound as the result.

This divide and conquer solution can be formally expressed
as a function :

\[
minfree(A) = search(A, 0, |A|-1)
\]

\[
search(A, l, u) = \left \{
       \begin{array}
       {r@{\quad:\quad}l}
       l & A = \phi \\
       search(A'', m+1, u) &  |A'| = m - l + 1 \\
       search(A',  l, m) & otherwise
       \end{array}
\right.
\]

where
%TODO: Add reference to appendix for notation.

\[ \begin{array}{l}
m = \displaystyle \lfloor \frac{l+u}{2} \rfloor \\
A'  = \{ \forall x \in A \wedge x \leq m \} \\
A'' = \{ \forall x \in A \wedge x > m \} \\
\end{array} \]

It is obvious that this algorithm doesn't need any extra
space\footnote{One may argue that it
actually takes $O(\lg n)$ stack spaces for book-keeping. As
we'll see later, this can be eliminated either by tail
recursion optimization, or by manually
changing the recursion to iteration}. Each call
performs $O(|A|)$ comparison to build $A'$ and $A''$.
After that the problem scale halves.
So the time needed for this algorithm is $T(n) = T(n/2) + O(n)$
which reduce to $O(n)$ by the master therom. Another way to analyze the performance
is to observe that the first call takes $O(n)$
to build $A'$ and $A''$ and the second call takes
$O(n/2)$, and $O(n/4)$ for the third... The total
time is $O(n + n/2 + n/4 + ...) = O(2n) = O(n)$ .

In functional programming languages such as Scala,
partitioning a list has already been provided in the library\footnote{Refer to Appendix A for more about list partition.}
and this algorithm can be translated as the following\footnote{Examples in Haskell can be found in Appendix B}.

\lstset{language=Scala}
\begin{lstlisting}
def minFree(xs : Seq[Int]) : Int = {
  @tailrec def bsearch(xs : Seq[Int], l : Int, u : Int) : Int = {
    val m = (l + u) / 2
    val (as, bs) = xs partition (_ <= m)
    if (xs isEmpty)
      l
    else if ((as length) == m - l + 1)
      bsearch(bs, m + 1, u)
    else
      bsearch(as, l, m)
  }
  bsearch(xs, 0, xs length)
}
\end{lstlisting}

\subsection{Expressiveness vs. Performance}
Imperative language programmers may be concerned about the performance
of this kind of implementation. In this example, the number of recursive
calls is in $O(\lg n)$
, which means the stack size consumed is in $O(\lg n)$.
It's not free in terms of space. But if we want to avoid that
, we can eliminate the recursion by replacing it by an iteration
\footnote{This is done automatically in most functional languages
since the function is in tail recursive form which lends itself
perfectly to this transformation. In Scala, the annotation @tailrec instructs the compiler to perform this optimization.} which leads to the following Java program.

\lstset{language=Java}
\begin{lstlisting}
int findMinFree(int[] nums) {
    int l = 0, u = nums.length;
    while (u - l > 0) {
        int m = l + (u - l) / 2;
        int left, right;
        for (left = right = l; right < u; ++right)
            if (nums[right] <= m)
                swap(nums, left++, right);
        if (left < m + 1)
            u = left;
        else
            l = left;
    }
    return l;
}

static final void swap(int[] nums, int i , int j) {
    int t = nums[i];
    nums[i] = nums[j];
    nums[j] = t;
}
\end{lstlisting}

This program uses a `quick-sort' like approach to re-arrange the
array so that all the elements before $left$ are less than or equal
to $m$; while those between $left$ and $right$ are greater
than $m$. This is shown in figure \ref{fig:divide}.

\begin{figure}[htbp]
  \centering
      \begin{tikzpicture}[scale=0.8]
      \draw (1, 0) rectangle (5, 1) node (leq) [pos=.5] {$x[i] \leq m$}
            (5, 0) rectangle (9, 1) node (ge) [pos=.5] {$x[i] > m$}
            (9, 0) rectangle (11, 1) node (rest) [pos=.5] {...?...};
      \fill [black] (5, 0) rectangle (5.1, 1) node (leftbar) [pos=.5] {}
                    (9, 0) rectangle (9.1, 1) node (rightbar) [pos=.5] {};
      \draw (5, 2) node (left) {$left$}
            (9, 2) node (right) {$right$};
      \draw[thick, ->] (left) edge [bend right] (leftbar)
                       (right) edge [bend right] (rightbar);
      \end{tikzpicture}
  \caption{Divide the array, all $x[i] \leq m$ where $0 \leq i < left$; while all $x[i] > m$ where $left \leq i < right$. The left elements are unknown.} \label{fig:divide}
\end{figure}

This program is fast and it doesn't need extra stack space. However,
compared to the previous recursive Scala program, it's hard to read and the
expressiveness decreased. We have to balance performance
and expressiveness.

There are also linear time, constant space imperative solutions. The exercise behind this preface gives two examples.

\section{The number puzzle, power of data structure}

If the first problem, to find the minimum free number, is some what
useful in practice, this problem is a `pure' one for fun. The puzzle
is to find the 1,500th number, which only contains factor 2, 3 or 5\footnote{These numbers are known as Regular numbers or Hamming numbers. In numbere theory, they are called 5-smooth.}.
The first 3 numbers are of course 2, 3, and 5. Number $60 = 2^23^15^1$,
However it is the 25th number. Number $21 = 2^03^17^1$, isn't a valid
number because it contains a factor 7. The first 10 such numbers are list
as the following.

2,3,4,5,6,8,9,10,12,15

If we consider $1=2^03^05^0$, then 1 is also a valid number and it is
the first one.

\subsection{The brute-force solution}
It seems the solution is quite easy without need any serious algorithms.
We can check all numbers from 1, then extract all factors of 2, 3 and 5
to see if the left part is 1.

\begin{algorithmic}[1]
\Function{Get-Number}{$n$}
  \State $x \gets 1$
  \State $i \gets 0$
  \Loop
    \If{\Call{Valid?}{$x$}}
      \State $i \gets i + 1$
      \If{$i = n$}
        \State \Return $x$
      \EndIf
    \EndIf
    \State $x \gets x + 1$
  \EndLoop
\EndFunction
\Statex
\Function{Valid?}{$x$}
  \While{$x \bmod 2 = 0$}
    \State $x \gets x / 2$
  \EndWhile
  \While{$x \bmod 3 = 0$}
    \State $x \gets x / 3$
  \EndWhile
  \While{$x \bmod 5 = 0$}
    \State $x \gets x / 5$
  \EndWhile
  \If{$x = 1$}
    \State \Return $True$
  \Else
    \State \Return $False$
  \EndIf
\EndFunction
\end{algorithmic}

This `brute-force' algorithm works for most small $n$. However, to find
the 1500th number (which is 859963392), the C program based on this
algorithm takes 40.39 seconds in my computer. I have to kill the program
after 10 minutes when I increased $n$ to 15,000.

\subsection{Improvement 1}
Analysis of the above algorithm shows that modular and divide calculations
are very expensive \cite{Bentley}. And they executed a lot in loops.
Instead of checking a number contains only 2, 3, or 5 as factors, one
alternative solution is to construct such number by these factors.

We start from 1, and times it with 2, or 3, or 5 to generate rest numbers.
The problem turns to be how to generate the candidate number in order?
One handy way is to utilize the queue data structure.

A queue data structure is used to push elements at one end, and pops
them at the other. So that the element be pushed first is also
be popped out first. This property is called FIFO (First-In-First-Out).

The idea is to push 1 as the only element to the queue, then we pop
an element, times it with 2, 3, and 5, to get 3 new elements. We
then push them back to the queue in order. Note that, the new elements may
have already existed in the queue. In such case, we just drop the
element. The new element may also smaller than the others in the queue,
so we must put them to the correct position. Figure \ref{fig:queues}
illustrates this idea.

\begin{figure}[htbp]
       \begin{center}
       	  \includegraphics[scale=0.5]{img/q1.ps}
       	  \includegraphics[scale=0.5]{img/q2.ps}
       	  \includegraphics[scale=0.5]{img/q3.ps}
       	  \includegraphics[scale=0.5]{img/q4.ps}
        \caption{First 4 steps of constructing numbers with a queue. \newline
        1. Queue is initialized with 1 as the only element;\newline
        2. New elements 2, 3, and 5 are pushed back; \newline
        3. New elements 4, 6, and 10, are pushed back in order; \newline
        4. New elements 9 and 15 are pushed back, element 6 already exists.} \label{fig:queues}
       \end{center}
\end{figure}

This algorithm is shown as the following.

\begin{algorithmic}[1]
\Function{Get-Number}{$n$}
  \State $Q \gets NIL$
  \State \Call{Enqueue}{$Q, 1$}
  \While{$n > 0$}
    \State $x \gets$ \Call{Dequeue}{$Q$}
    \State \Call{Unique-Enqueue}{$Q, 2x$}
    \State \Call{Unique-Enqueue}{$Q, 3x$}
    \State \Call{Unique-Enqueue}{$Q, 5x$}
    \State $n \gets n-1$
  \EndWhile
  \State \Return $x$
\EndFunction
\Statex
\Function{Unique-Enqueue}{$Q, x$}
  \State $i \gets 0$
  \While{$i < |Q| \wedge Q[i] < x$}
    \State $i \gets i + 1$
  \EndWhile
  \If{$i < |Q| \wedge x = Q[i]$}
    \State \Return
  \EndIf
  \State \Call{Insert}{$Q, i, x$}
\EndFunction
\end{algorithmic}

The insert function takes $O(|Q|)$ time to find the proper position and insert
it. If the element has already existed, it just returns.

A rough estimation tells that the length of the queue increase proportion to $n$,
(Each time, we extract one element, and pushed 3 new, the increase ratio $\leq$ 2),
so the total running time is $O(1+2+3+...+n) = O(n^2)$.

Figure\ref{fig:big-O-1q} shows the number of queue access time against $n$.
It is quadratic curve which reflect the $O(n^2)$ performance.

\begin{figure}[htbp]
       \begin{center}
       	  \includegraphics[scale=0.5]{img/big-O-1q.eps}
        \caption{Queue access count v.s. $n$.} \label{fig:big-O-1q}
       \end{center}
\end{figure}

The C program based on this algorithm takes only 0.016[s] to get the right answer
859963392. Which is 2500 times faster than the brute force solution.

%% Functional 1Q solution
Improvement 1 can also be considered in recursive way. Suppose $X$ is the infinity
series for all numbers which only contain factors of 2, 3, or 5. The following
formula shows an interesting relationship.

\be
  X = \{1\} \cup \{2x: \forall x \in X\} \cup \{3x: \forall x \in X \} \cup \{5x: \forall x \in X \}
\ee

Where we can define $\cup$ to a special form so that all elements are stored in order
as well as unique to each other. Suppose that $X=\{x_1, x_2, x_3...\}$, $Y=\{y_1, y_2, y_3, ...\}$, $X' = \{x_2, x_3, ...\}$ and $Y'=\{y_2, y_3, ...\}$. We have

\[
X \cup Y = \left \{
  \begin{array}{r@{\quad:\quad}l}
  \{ x_1, X' \cup Y \} & x_1 < y_1 \\
  \{ x_1, X' \cup Y' \} & x_1 = y_1 \\
  \{ y_1, X \cup Y' \} & x_1 > y_1
  \end{array}
\right.
\]

In a functional programming language such as Scala, which supports
support model the lazy evaluation with stream, The above infinity series function can be translate into the following program\footnote{Refer to Appendix B for the Haskell example, which support lazy evaluation by default.}.

\lstset{language=Scala}
\begin{lstlisting}
object RegNum {
  lazy val ns: Stream[BigInt] = 1 #:: merge(ns map {_ * 2},
                                      merge(ns map {_ * 3},
                                            ns map {_ * 5}))

  def merge(a: Stream[BigInt], b: Stream[BigInt]): Stream[BigInt] =
    if (a.head < b.head) a.head #:: merge(a.tail, b)
    else if (a.head == b.head) a.head #:: merge(a.tail, b.tail)
    else b.head #:: merge(a, b.tail)
}
\end{lstlisting}

By evaluate \texttt{RegNum.ns.take(1500).last}, we can get the 1500th number, 859963392.

\subsection{Improvement 2}
Considering the above solution, although it is much faster than the brute-force one,
It still has some drawbacks. It produces many duplicated numbers and they are
finally dropped when examine the queue. Secondly, it does linear time scan and insertion to keep the order of all elements in the queue, which degrade the ENQUEUE operation
from $O(1)$ to $O(|Q|)$.

If we use three queues instead, we can improve the solution one
step ahead. Denote these queues as $Q_2$, $Q_3$, and $Q_5$, and we initialize
them as $Q_2=\{ 2 \}$, $Q_3 = \{ 3\}$ and $Q_5 = \{ 5 \}$. Each time we DEQUEUEed
the smallest one from $Q_2$, $Q_3$, and $Q_5$ as $x$. And do the following test:

\begin{itemize}
\item If $x$ comes from $Q_2$, we ENQUEUE $2x$, $3x$, and $5x$ back to
$Q_2$, $Q_3$, and $Q_5$ respectively;
\item If $x$ comes from $Q_3$, we only need ENQUEUE $3x$ to $Q_3$, and $5x$ to $Q_5$;
We needn't ENQUEUE $2x$ to $Q_2$, because $2x$ have already existed in $Q_3$;
\item If $x$ comes from $Q_5$, we only need ENQUEUE $5x$ to $Q_5$; there is
no need to ENQUEUE $2x$, $3x$ to $Q_2$, $Q_3$ because they have already been
in the queues;
\end{itemize}

We repeatedly DEQUEUE the smallest one until we find the $n$-th element.

\begin{figure}[htbp]
       \begin{center}
       	  \includegraphics[scale=0.5]{img/q235-1.ps}
       	  \includegraphics[scale=0.5]{img/q235-2.ps}
       	  \includegraphics[scale=0.5]{img/q235-3.ps}
       	  \includegraphics[scale=0.5]{img/q235-4.ps}
        \caption{First 4 steps of constructing numbers with $Q_2$, $Q_3$, and $Q_5$. \newline
        1. Queues are initialized with 2, 3, 5 as the only element;\newline
        2. New elements 4, 6, and 10 are pushed back; \newline
        3. New elements 9, and 15, are pushed back; \newline
        4. New elements 8, 12, and 20 are pushed back; \newline
        5. New element 25 is pushed back.} \label{fig:q235}
       \end{center}
\end{figure}

The algorithm based on this idea is implemented as below.

\begin{algorithmic}[1]
\Function{Get-Number}{$n$}
  \If{$n = 1$}
    \State \Return $1$
  \Else
    \State $Q_2 \gets \{ 2 \}$
    \State $Q_3 \gets \{ 3 \}$
    \State $Q_5 \gets \{ 5 \}$
    \While{$n > 1$}
      \State $x \gets min($\Call{Head}{$Q_2$}, \Call{Head}{$Q_3$}, \Call{Head}{$Q_5$}$)$
      \If{$x = $ \Call{Head}{$Q_2$}}
        \State \Call{Dequeue}{$Q_2$}
        \State \Call{Enqueue}{$Q_2, 2x$}
        \State \Call{Enqueue}{$Q_3, 3x$}
        \State \Call{Enqueue}{$Q_5, 5x$}
      \ElsIf{$x=$ \Call{Head}{$Q_3$}}
        \State \Call{Dequeue}{$Q_3$}
        \State \Call{Enqueue}{$Q_3, 3x$}
        \State \Call{Enqueue}{$Q_5, 5x$}
      \Else
        \State \Call{Dequeue}{$Q_5$}
        \State \Call{Enqueue}{$Q_5, 5x$}
      \EndIf
      \State $n \gets n - 1$
    \EndWhile
    \State \Return $x$
  \EndIf
\EndFunction
\end{algorithmic}

This algorithm loops $n$ times, and within each loop, it extract one head
element from the three queues, which takes constant time. Then it appends
one to three new elements at the end of queues which bounds to constant time
too. So the total time of the algorithm bounds to $O(n)$. The Java program
translated from this algorithm shown below takes less than 1 ms to
produce the 1500th number, 859963392.

\lstset{language=Java}
\begin{lstlisting}
static long min(long a, long b, long c) {
    return Math.min(a, Math.min(b, c));
}

public long getAt(int n) {
    if (n == 1) return 1;
    Queue<Long> q2 = new LinkedList<>(Arrays.asList(new Long[]{2L})),
                q3 = new LinkedList<>(Arrays.asList(new Long[]{3L})),
                q5 = new LinkedList<>(Arrays.asList(new Long[]{5L}));
    long x = 1;
    while (n-- > 1) {
        x = min(q2.peek(), q3.peek(), q5.peek());
        if (x == q2.peek()) {
            q2.poll();
            q2.offer(x * 2);
            q3.offer(x * 3);
            q5.offer(x * 5);
        } else if (x == q3.peek()) {
            q3.poll();
            q3.offer(x * 3);
            q5.offer(x * 5);
        } else {
            q5.poll();
            q5.offer(x * 5);
        }
    }
    return x;
}
\end{lstlisting}

This solution can be also implemented in Functional way. We define
a function $take(n)$, which will return the first $n$ numbers contains
only factor 2, 3, or 5.

\[
  take(n) = f(n, \{1\}, \{2\}, \{3\}, \{5\})
\]
Where
\[
 f(n, X, Q_2, Q_3, Q_5) = \left \{
  \begin{array}{r@{\quad:\quad}l}
  X & n = 1 \\
  f(n-1, X \cup \{x\}, Q_2', Q_3', Q_5') & otherwise
  \end{array}
\right.
\]

\[
 x = min(Q_{21}, Q_{31}, Q_{51})
\]
\[
 Q_2', Q_3', Q_5' = \left \{
 \begin{array}{r@{\quad:\quad}l}
 \{Q_{22}, Q_{23}, ...\} \cup \{2x\}, Q_3 \cup \{3x\}, Q_5 \cup \{5x\} & x = Q_{21} \\
 Q_2, \{Q_{32}, Q_{33}, ...\} \cup \{3x\}, Q5 \cup \{5x\} & x = Q_{31} \\
 Q_2, Q_3, \{Q_{52}, Q_{53}, ...\} \cup \{5x\} & x = Q_{51}
 \end{array}
 \right.
\]

And these functional definition can be realized in Scala as the following\footnote{The practical Scala program typically use mutable queues and sequence to avoid performance overhead, we show a `purely' functional approach for illustration purpose.}.

\lstset{language=Scala}
\begin{lstlisting}
def take(n: Int) = {
  def generate(n: Int, xs: Seq[BigInt],
               q2: Queue[BigInt],
               q3: Queue[BigInt],
               q5: Queue[BigInt]) : Seq[BigInt] = {
    if (n == 1) xs
    else {
      val x = q2.head min q3.head min q5.head
      if (x == q2.head)
        generate(n - 1, xs :+ x, q2.tail :+ 2 * x,
                                 q3 :+ 3 * x,
                                 q5 :+ 5 * x)
      else if (x == q3.head)
        generate(n - 1, xs :+ x, q2,
                                 q3.tail :+ 3 * x,
                                 q5 :+ 5 * x)
      else
        generate(n - 1, xs :+ x, q2, q3, q5.tail :+ 5 * x)
    }
  }
  generate(n, Seq(1), Queue(2), Queue(3), Queue(5))
}
\end{lstlisting}

Run \texttt{take(1500).last} will generate the correct answer 859963392.

% ================================================================
%                 Short summary
% ================================================================
\section{Notes and short summary}
If review the 2 puzzles, we found in both cases, the brute-force solutions
are so weak. In the first problem, it's quite poor in dealing with
long number list, while in the second problem, it doesn't work at all.

The first problem shows the power of algorithms, while the second
problem tells why data structure is important. There are plenty
of interesting problems, which are hard to solve before computer
was invented. With the aid of computer and programming, we are able
to find the answer in a quite different way. Compare to what we
learned in mathematics course in school, we haven't been taught the method
like this.

While there have been already a lot of wonderful books about
algorithms, data structures and math, however, few of them
provide the comparison between the procedural solution and
the functional solution. From the above examples, functional solution
can very expressive
and they are close to what we are familiar in mathematics.

This book focus on providing both imperative and functional
algorithms and data structures. Many functional data structures
can be referenced from Okasaki's book\cite{okasaki-book}. While
the imperative ones can be founded in classic text books e.g. \cite{CLRS}
or even in WIKIpedia. This edition provoides examples in Java
and Scala. In order to make it easy to read
by programmers with different background, pseudo code and mathematical
function are the regular descriptions of each post.

The author is NOT a native English speaker, the reason why
this book is only available in English for the time being
is because the contents are still changing frequently. Any
feedback, comments, or criticizes are welcome.

\section{Structure of the contents}
In the following series of post, I'll first introduce about
elementary data structures, because many
algorithms need knowledge of data structures as prerequisite.

The `hello world' data structure, binary search tree is the
first topic; Then we introduce how to solve the balance problem
of binary search tree. After that, I'll show other interesting
trees, like Radix trees and B-trees.

The second part of data structures is about heaps. We'll
provide a general Heap definition and introduce about binary
heaps by array and by explicit binary trees. Then we'll
extend to K-ary heaps including Binomial heaps, Fibonacci
heaps, and pairing heaps.

Array and queues are considered among the easiest data structures
typically, However, we'll show how difficult to implement
them in the third part.

As the elementary sort algorithms, we'll introduce insertion
sort, quick sort, merge sort etc in both imperative way
and functional way.

The final part is about searching, besides the element
searching, we'll also show string matching algorithms
such as KMP.

\begin{Exercise}
\begin{itemize}
\item There are purely imperative methods to achieve the linear time, constant space solution for the min-free number problem. Here are two of them.
  \begin{itemize}
  \item Pigeonhole sort. We can put the $i$-th number $x$ to the position where it should be, the $x$-th number. When $x > n$, we can skip it. Otherwise, we exchange the number at the $i$-th and the $x$-th positions. Since the number we swapped to $i$-th position may not be $i$, we need repeatedly do this till either it exceeds $n$, or it becomes $i$. We iterate on $i$ from 1 to $n$, process all numbers. As each number will only swapped one time, this processing is linear (can you prove it formally?). Next we scan the array with the second round, if at any position $i$, the number isn't $i$, we find the answer. Otherwise, it means the array is 'full', and we return $n+1$ as the min free number.
  \item Sign encoding. We want to know if a number does exist. Exist or not is a kind of binary information. we can encode it as the sign of the number. If number $x$ exists in the sequence, we mark the $x$-th number as negative. After we complete this marking for all numbers which are not greater than $n$, we can scan the sequence from left, find the first positive number. And that position is the answer.
  \end{itemize}
Realize these two methods in your favorate imperative programming langauge.
\item When Andrew Koening started the discussion about Hamming number problem in Dr. Dobbs, Cassio Neri gave a ``flattened'' method to realize the infinite lazy merge. This can be expressed as the below algorithm.
\begin{algorithmic}[1]
\State $H \gets \{1, ...\}$
\State $n \gets 0$
\State $i \gets 0$, $j \gets 0$, $k \gets 0$
\State $x_2 \gets 2H[i]$, $x_3 \gets 3H[j]$, $x_5 \gets 5H[k]$
\Loop
  \State $n \gets n + 1$
  \State $H[n] \gets$ \Call{min}{$x_2, x_3, x_5$}
  \If{$x_2 = H[n]$}
    \State $i \gets i + 1$
    \State $x_2 \gets 2H[i]$
  \EndIf
  \If{$x_3 = H[n]$}
    \State $j \gets j + 1$
    \State $x_3 \gets 2H[j]$
  \EndIf
  \If{$x_5 = H[n]$}
    \State $k \gets k + 1$
    \State $x_5 \gets 2H[k]$
  \EndIf
\EndLoop
\end{algorithmic}
Realize this algorithm in your favorate imperative programming language.
\end{itemize}
\end{Exercise}

\ifx\wholebook\relax \else
\begin{thebibliography}{99}

\bibitem{fp-book}
Richard Bird. ``Pearls of functional algorithm design''. Cambridge University Press; 1 edition (November 1, 2010). ISBN-10: 0521513383. pp1 - pp6.

\bibitem{Bentley}
Jon Bentley. ``Programming Pearls(2nd Edition)''. Addison-Wesley Professional; 2 edition (October 7, 1999). ISBN-13: 978-0201657883

\bibitem{okasaki-book}
Chris Okasaki. ``Purely Functional Data Structures''. Cambridge university press, (July 1, 1999), ISBN-13: 978-0521663502

\bibitem{CLRS}
Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest and Clifford Stein. ``Introduction to Algorithms, Second Edition''. The MIT Press, 2001. ISBN: 0262032937.

\end{thebibliography}

\expandafter\enddocument
%\end{document}

\fi
