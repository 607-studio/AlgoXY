\ifx\wholebook\relax \else
% ------------------------

\documentclass{article}
%------------------- Other types of document example ------------------------
%
%\documentclass[twocolumn]{IEEEtran-new}
%\documentclass[12pt,twoside,draft]{IEEEtran}
%\documentstyle[9pt,twocolumn,technote,twoside]{IEEEtran}
%
%-----------------------------------------------------------------------------
%\input{../../../common.tex}
\input{../../../common-en.tex}

\setcounter{page}{1}

\begin{document}

%--------------------------

% ================================================================
%                 COVER PAGE
% ================================================================

\title{Haskell例子程序}

\author{Larry~LIU~Xinyu
\thanks{{\bfseries Larry LIU Xinyu } \newline
  Email: liuxinyu95@gmail.com \newline}
  }

\maketitle
\fi

\markboth{Haskell例子程序}{Elementary Algorithms}

\ifx\wholebook\relax
\chapter{Haskell例子程序}
\numberwithin{Exercise}{chapter}
\fi

本附录列出了各个章节中对应的Haskell例子程序。

\subsection{最小可用数字问题}
分而治之的最小可用数字问题解法。

\lstset{language=Haskell}
\begin{lstlisting}
import Data.List

minFree xs = bsearch xs 0 (length xs - 1)

bsearch xs l u | xs == [] = l
               | length as == m - l + 1 = bsearch bs (m + 1) u
               | otherwise = bsearch as l m
    where
      m = (l + u) `div` 2
      (as, bs) = partition (<=m) xs
\end{lstlisting}

\subsection{正规数（哈明数）问题}
寻找只包含2、3、或5为因子的第$k$个数。下面的方法使用了Haskell的惰性求值特性和无穷流。

\begin{lstlisting}
merge (x:xs) (y:ys) | x <y = x : merge xs (y:ys)
                    | x == y = x : merge xs ys
                    | otherwise = y : merge (x:xs) ys

ns = 1:merge (map (*2) ns) (merge (map (*3) ns) (map (*5) ns))
\end{lstlisting}

下面的代码给出第1500个正规数。
\begin{verbatim}
last $ take 1500 ns
\end{verbatim}

我们也可以使用三个队列来产生正规数。

\begin{lstlisting}
ks 1 xs _ = xs
ks n xs (q2, q3, q5) = ks (n-1) (xs++[x]) update
    where
      x = minimum $ map head [q2, q3, q5]
      update | x == head q2 = ((tail q2)++[x*2], q3++[x*3], q5++[x*5])
             | x == head q3 = (q2, (tail q3)++[x*3], q5++[x*5])
             | otherwise = (q2, q3, (tail q5)++[x*5])

takeN n = ks n [1] ([2], [3], [5])
\end{lstlisting}

执行\texttt{last \$ takeN 1500}即产生第1500个正规数859963392。

\section{二叉搜索树}

\subsection{二叉搜索树的定义}

二叉搜索树的代数数据类型定义。

\begin{lstlisting}
data Tree a = Empty
            | Node (Tree a) a (Tree a)
\end{lstlisting}

\subsection{插入}

\begin{lstlisting}
insert Empty k = Node Empty k Empty
insert (Node l x r) k | k < x = Node (insert l k) x r
                      | otherwise = Node l x (insert r k)
\end{lstlisting}

\subsection{将二叉搜索树转换为有序列表}

\begin{lstlisting}
toList Empty = []
toList (Node l x r) = toList l ++ [x] ++ toList r
\end{lstlisting}

\subsection{二叉搜索树的查找}

\begin{lstlisting}
lookup Empty _ = Empty
lookup t@(Node l k r) x | k == x = t
                        | x < k = lookup l x
                        | otherwise = lookup r x
\end{lstlisting}

\subsection{从二叉搜索树中删除元素}

\begin{lstlisting}
delete Empty _ = Empty
delete (Node l k r) x | x < k = (Node (delete l x) k r)
                      | x > k = (Node l k (delete r x))
                      -- x == k
                      | isEmpty l = r
                      | isEmpty r = l
                      | otherwise = (Node l k' (delete r k'))
                          where k' = min r
\end{lstlisting}

\section{红黑树}

\subsection{插入}

使用模式匹配的红黑树插入算法。

\begin{lstlisting}
data Color = R | B
data RBTree a = Empty
              | Node Color (RBTree a) a (RBTree a)

insert::(Ord a)=>RBTree a -> a -> RBTree a
insert t x = makeBlack $ ins t where
    ins Empty = Node R Empty x Empty
    ins (Node color l k r)
        | x < k     = balance color (ins l) k r
        | otherwise = balance color l k (ins r)
    makeBlack(Node _ l k r) = Node B l k r

balance::Color -> RBTree a -> a -> RBTree a -> RBTree a
balance B (Node R (Node R a x b) y c) z d =
        Node R (Node B a x b) y (Node B c z d)
balance B (Node R a x (Node R b y c)) z d =
        Node R (Node B a x b) y (Node B c z d)
balance B a x (Node R b y (Node R c z d)) =
        Node R (Node B a x b) y (Node B c z d)
balance B a x (Node R (Node R b y c) z d) =
        Node R (Node B a x b) y (Node B c z d)
balance color l k r = Node color l k r

\end{lstlisting}

\subsection{删除}

使用“双重黑色”概念实现的红黑树删除算法。

\begin{lstlisting}
data Color = R | B | BB deriving (Show, Eq) -- BB为双重黑色
data RBTree a = Empty
              | Node Color (RBTree a) a (RBTree a)
              | BBEmpty -- 双重黑色空节点

min::RBTree a -> a
min (Node _ Empty x _) = x
min (Node _ l _ _) = min l

isEmpty :: (RBTree a) -> Bool
isEmpty Empty = True
isEmpty _ = False

delete::(Ord a)=>RBTree a -> a -> RBTree a
delete t x = blackenRoot (del t x) where
    del Empty _ = Empty
    del (Node color l k r) x
        | x < k = fixDB color (del l x) k r
        | x > k = fixDB color l k (del r x)
        -- x == k, 删除此节点
        | isEmpty l = if color==B then makeBlack r else r
        | isEmpty r = if color==B then makeBlack l else l
        | otherwise = fixDB color l k' (del r k') where k'= min r
    blackenRoot (Node _ l k r) = Node B l k r
    blackenRoot _ = Empty

makeBlack::RBTree a -> RBTree a
makeBlack (Node B l k r) = Node BB l k r -- 双重黑色
makeBlack (Node _ l k r) = Node B l k r
makeBlack Empty = BBEmpty
makeBlack t = t

fixDB::Color -> RBTree a -> a -> RBTree a -> RBTree a
-- 兄弟节点为黑色，有一个红色的侄子
fixDB color a@(Node BB _ _ _) x (Node B (Node R b y c) z d) =
      Node color (Node B (makeBlack a) x b) y (Node B c z d)
fixDB color BBEmpty x (Node B (Node R b y c) z d) =
      Node color (Node B Empty x b) y (Node B c z d)
fixDB color a@(Node BB _ _ _) x (Node B b y (Node R c z d)) =
      Node color (Node B (makeBlack a) x b) y (Node B c z d)
fixDB color BBEmpty x (Node B b y (Node R c z d)) =
      Node color (Node B Empty x b) y (Node B c z d)
fixDB color (Node B a x (Node R b y c)) z d@(Node BB _ _ _) =
      Node color (Node B a x b) y (Node B c z (makeBlack d))
fixDB color (Node B a x (Node R b y c)) z BBEmpty =
      Node color (Node B a x b) y (Node B c z Empty)
fixDB color (Node B (Node R a x b) y c) z d@(Node BB _ _ _) =
      Node color (Node B a x b) y (Node B c z (makeBlack d))
fixDB color (Node B (Node R a x b) y c) z BBEmpty =
      Node color (Node B a x b) y (Node B c z Empty)
-- 兄弟为红色
fixDB B a@(Node BB _ _ _) x (Node R b y c) = fixDB B (fixDB R a x b) y c
fixDB B a@BBEmpty x (Node R b y c) = fixDB B (fixDB R a x b) y c
fixDB B (Node R a x b) y c@(Node BB _ _ _) = fixDB B a x (fixDB R b y c)
fixDB B (Node R a x b) y c@BBEmpty = fixDB B a x (fixDB R b y c)
-- 兄弟和两个侄子都是黑色。
fixDB color a@(Node BB _ _ _) x (Node B b y c) =
      makeBlack (Node color (makeBlack a) x (Node R b y c))
fixDB color BBEmpty x (Node B b y c) =
      makeBlack (Node color Empty x (Node R b y c))
fixDB color (Node B a x b) y c@(Node BB _ _ _) = m
      akeBlack (Node color (Node R a x b) y (makeBlack c))
fixDB color (Node B a x b) y BBEmpty =
      makeBlack (Node color (Node R a x b) y Empty)
-- 其他情况
fixDB color l k r = Node color l k r
\end{lstlisting}

\ifx\wholebook\relax \else
\end{document}
\fi
