\ifx\wholebook\relax \else
% ------------------------

\documentclass{article}
%------------------- Other types of document example ------------------------
%
%\documentclass[twocolumn]{IEEEtran-new}
%\documentclass[12pt,twoside,draft]{IEEEtran}
%\documentstyle[9pt,twocolumn,technote,twoside]{IEEEtran}
%
%-----------------------------------------------------------------------------
%\input{../../../common.tex}
\input{../../../common-en.tex}

\setcounter{page}{1}

\begin{document}

%--------------------------

% ================================================================
%                 COVER PAGE
% ================================================================

\title{Haskell例子程序}

\author{Larry~LIU~Xinyu
\thanks{{\bfseries Larry LIU Xinyu } \newline
  Email: liuxinyu95@gmail.com \newline}
  }

\maketitle
\fi

\markboth{Haskell例子程序}{Elementary Algorithms}

\ifx\wholebook\relax
\chapter{Haskell例子程序}
\numberwithin{Exercise}{chapter}
\fi

本附录列出了各个章节中对应的Haskell例子程序。

\subsection{最小可用数字问题}
分而治之的最小可用数字问题解法。

\lstset{language=Haskell}
\begin{lstlisting}
import Data.List

minFree xs = bsearch xs 0 (length xs - 1)

bsearch xs l u | xs == [] = l
               | length as == m - l + 1 = bsearch bs (m + 1) u
               | otherwise = bsearch as l m
    where
      m = (l + u) `div` 2
      (as, bs) = partition (<=m) xs
\end{lstlisting}

\subsection{正规数（哈明数）问题}
寻找只包含2、3、或5为因子的第$k$个数。下面的方法使用了Haskell的惰性求值特性和无穷流。

\begin{lstlisting}
merge (x:xs) (y:ys) | x <y = x : merge xs (y:ys)
                    | x == y = x : merge xs ys
                    | otherwise = y : merge (x:xs) ys

ns = 1:merge (map (*2) ns) (merge (map (*3) ns) (map (*5) ns))
\end{lstlisting}

下面的代码给出第1500个正规数。
\begin{verbatim}
last $ take 1500 ns
\end{verbatim}

我们也可以使用三个队列来产生正规数。

\begin{lstlisting}
ks 1 xs _ = xs
ks n xs (q2, q3, q5) = ks (n-1) (xs++[x]) update
    where
      x = minimum $ map head [q2, q3, q5]
      update | x == head q2 = ((tail q2)++[x*2], q3++[x*3], q5++[x*5])
             | x == head q3 = (q2, (tail q3)++[x*3], q5++[x*5])
             | otherwise = (q2, q3, (tail q5)++[x*5])

takeN n = ks n [1] ([2], [3], [5])
\end{lstlisting}

执行\texttt{last \$ takeN 1500}即产生第1500个正规数859963392。

\ifx\wholebook\relax \else
\end{document}
\fi
