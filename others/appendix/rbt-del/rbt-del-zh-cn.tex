\ifx\wholebook\relax \else
% ------------------------

\documentclass[UTF8]{article}
%------------------- Other types of document example ------------------------
%
%\documentclass[twocolumn]{IEEEtran-new}
%\documentclass[12pt,twoside,draft]{IEEEtran}
%\documentstyle[9pt,twocolumn,technote,twoside]{IEEEtran}
%
%-----------------------------------------------------------------------------
\input{../../../common-zh-cn.tex}

\setcounter{page}{1}

\begin{document}

%--------------------------

% ================================================================
%                 COVER PAGE
% ================================================================

\title{红黑树的命令式删除算法}

\author{刘新宇
\thanks{{\bfseries 刘新宇} \newline
  Email: liuxinyu95@gmail.com \newline}
  }

\maketitle
\fi

\markboth{红黑树}{初等算法}

\ifx\wholebook\relax
\chapter{红黑树的命令式删除算法}
\numberwithin{Exercise}{chapter}
\fi

% ================================================================
%                 Introduction
% ================================================================
\index{红黑树!命令式删除}

本附录包含红黑树的命令式删除算法。我们需要在普通二叉搜索树删除算法的基础上，通过旋转和重新染色恢复红黑树的性质，以保持树的平衡。我们在红黑树一章中指出，当删除黑色节点时，会破坏红黑树的第五条性质。使得某一路径上的黑色节点数目减少。为此，我们引入“双重黑色”节点，来保持所删除路径上的黑色节点数目不变。

\section{双重黑色}

为了支持“双重黑色”的节点，我们需要增加颜色的定义。如下面的C++例子代码所示。

\lstset{language=C++}
\begin{lstlisting}
enum class Color { RED, BLACK, DOUBLY_BLACK };
\end{lstlisting}

在删除一个节点时，我们复用二叉搜索树的删除算法，并记录被删除节点的父节点。如果被删除节点的颜色是黑色我们需要通过处理保持黑色的属性，然后再进行进一步修复。

\begin{algorithmic}[1]
\Function{Delete}{$T, x$}
  \State $p \gets$ \Call{Parent}{$x$}
  \State $q \gets$ NIL
  \If{\Call{Left}{$x$} = NIL}
    \State $q \gets$ \Call{Right}{$x$}
    \State replace $x$ with \Call{Right}{$x$}
  \ElsIf{\Call{Right}{$x$} = NIL}
    \State $q \gets$ \Call{Left}{$x$}
    \State replace $x$ with \Call{Left}{$x$}
  \Else
    \State $y \gets$ \textproc{Min}(\Call{Right}{$x$})
    \State $p \gets$ \Call{Parent}{$y$}
    \State $q \gets$ \Call{Right}{$y$}
    \State \Call{Key}{$x$} $\gets$ \Call{Key}{$y$}
    \State copy satellite data from $y$ to $x$
    \State replace $y$ with \Call{Right}{$y$}
    \State $x \gets y$
  \EndIf
  \If{\Call{Color}{$x$} = BLACK}
    \State $T \gets$ \textproc{Delete-Fix}($T$, \Call{Make-Black}{$p$, $q$}, $q$ = NIL?)
  \EndIf
  \State release $x$
  \State \Return $T$
\EndFunction
\end{algorithmic}

删除算法接受树的根节点$T$和待删除节点$x$。如果待删除节点存在一个为空的分支，我们可以将$x$“切下”，并用另一个分支$q$来替代$x$。否则，我们在$x$的右子树中找到最小的节点$y$，用$y$替换$x$。然后递归地将$y$“切下”。如果被删除的节点$x$的颜色为黑色，我们调用\textproc{Make-Black}{$p$, $q$}，来保持黑色属性，以便进行下一步的修复。

\begin{algorithmic}[1]
\Function{Make-Black}{$p$, $q$}
  \If{$p$ = NIL $\land$ $q$ = NIL}
    \State \Return NIL \Comment{删除只有一个叶子节点的树后，变为空}
  \ElsIf{$q$ = NIL}
    \State $n \gets$ Doubly Black NIL
    \State \Call{Parent}{$n$} $\gets p$
    \State \Return $n$
  \Else
    \State \Return \Call{Blacken}{$q$}
  \EndIf
\EndFunction
\end{algorithmic}

如果传入\textproc{Make-Black}的参数$p$和$q$都为空，说明我们在删除只有一个叶子节点的树，删除后树变为空。否则如果父节点$p$不为空，而节点$q$为空。说明我们删除了一个黑色的叶子节点。这相当于，此时一个NIL节点替换了被删除的黑色节点。根据红黑树的性质3，NIL节点实际上都是黑色的。我们可以把这一NIL节点变成“双重黑色”NIL节点来保持其所在路径上的黑色节点数目不变。最后，如果$p$、$q$都不为空，我们调用\textproc{Blacken}检查$q$的颜色，如果是红色的，将它重新染成黑色，如果$q$已经是黑色的，我们将它染成双重黑色。

为了最终恢复红黑树的性质，我们需要通过树的旋转操作和重新染色，最终去掉“双重黑色”。这里有三种情况需要处理。每一种情况中，双重黑色的节点即可以是普通节点，也可以是双重黑色的空节点。我们首先看第一种情况。

\subsection{双重黑色节点的兄弟为黑色，并且该兄弟节点有一个红色子节点}
对于这种情况，我们可以通过旋转操作来修复。总共有四种不同的细分情况，它们全部可以变换到一种统一的形式。如图\ref{fig:del-case1}所示。

\begin{figure}[htbp]
   \centering
   \includegraphics[scale=0.4]{../../../datastruct/tree/red-black-tree/img/del-case1.eps}
   \caption{双重黑色节点的兄弟为黑色，并且该兄弟节点有一个红色子节点。这种情况可以通过一次旋转操作来修复。}
   \label{fig:del-case1}
\end{figure}

下面的算法描述了针对这一情况的处理。

\begin{algorithmic}[1]
\Function{Delete-Fix}{$T$, $x$, $f$}
  \State $n \gets$ NIL
  \If{$f$ = True}  \Comment{$x$是一个双重黑色NIL节点}
    \State $n \gets x$
  \EndIf
  \If{$x$ = NIL} \Comment{将只有一个叶子节点的树删空}
    \State \Return NIL
  \EndIf
  \While{$x \neq T \lor$ \Call{Color}{$x$} $= \mathcal{B}^2$}
    \Comment{$x$ isn't root or $x$ isn't doubly black}
    \If{\Call{Sibling}{$x$} $\neq$ NIL} \Comment{双重黑色节点的兄弟节点不为空}
        \State $s \gets$ \Call{Sibling}{$x$}
        \State ...
        \If{$s$ is black $\land$ \Call{Left}{$s$} is red}
          \Comment{兄弟为黑，一个侄子为红}
          \If{$x = $ \textproc{Left}(\Call{Parent}{$x$})}
            \Comment{双重黑色节点是其父的左孩子}
            \State set $x$, \Call{Parent}{$x$}, and \Call{Left}{$s$} all black
            \State $T \gets$ \Call{Rotate-Right}{$T$, $s$}
            \State $T \gets$ \textproc{Rotate-Left}($T$, \Call{Parent}{$x$})
          \Else \Comment{双重黑色节点是其父的右孩子}
            \State set $x$, \Call{Parent}{$x$}, $s$, and \Call{Left}{$s$} all black
            \State $T \gets$ \textproc{Rotate-Right}($T$, \Call{Parent}{$x$})
          \EndIf
        \ElsIf{$s$ is black $\land$ \Call{Right}{$s$} is red}
          \If{$x = $ \textproc{Left}(\Call{Parent}{$x$})}
            \State set $x$, \Call{Parent}{$x$}, $s$, and \Call{Right}{$s$} all black
            \State $T \gets$ \textproc{Rotate-Left}($T$, \Call{Parent}{$x$})
          \Else
            \State set $x$, \Call{Parent}{$x$}, and \Call{Right}{$s$} all black
            \State $T \gets$ \Call{Rotate-Left}{$T$, $s$}
            \State $T \gets$ \textproc{Rotate-Right}($T$, \Call{Parent}{$x$})
          \EndIf
        \State ...
        \EndIf
    \EndIf
  \EndWhile
\EndFunction
\end{algorithmic}

\subsection{双重黑色节点的兄弟节点为红色}
这种情况下，我们可以通过旋转，将双重黑色恢复为普通的黑色节点。如图\ref{fig:del-case2}所示，将左侧的树旋转到右侧的结构后，可将双重黑色的节点$a$或$c$恢复为黑色。

\begin{figure}[htbp]
  \centering
  \includegraphics[scale=0.4]{../../../datastruct/tree/red-black-tree/img/del-case3.eps}
  \caption{双重黑色节点的兄弟节点为红色} \label{fig:del-case2}
\end{figure}

我们在此前给出算法上增加这一处理。

\begin{algorithmic}[1]
\Function{Delete-Fix}{$T$, $x$, $f$}
  \State $n \gets$ NIL
  \If{$f$ = True}  \Comment{$x$是一个双重黑色NIL节点}
    \State $n \gets x$
  \EndIf
  \If{$x$ = NIL} \Comment{将只有一个叶子节点的树删空}
    \State \Return NIL
  \EndIf
  \While{$x \neq T \lor$ \Call{Color}{$x$} $= \mathcal{B}^2$}
    \Comment{$x$ isn't root or $x$ isn't doubly black}
    \If{\Call{Sibling}{$x$} $\neq$ NIL} \Comment{双重黑色节点的兄弟节点不为空}
        \State $s \gets$ \Call{Sibling}{$x$}
        \If{$s$ is red} \Comment{兄弟为红色}
          \State set \Call{Parent}{$x$} red
          \State set $s$ black
          \If{$x = $ \textproc{Left}(\Call{Parent}{$x$})} \Comment{$x$为其父的左孩子}
            \State $T \gets$ \textproc{Rotate-Left}{$T$, \Call{Parent}{$x$}}
          \Else \Comment{$x$为其父的右孩子}
            \State $T \gets$ \textproc{Rotate-Right}{$T$, \Call{Parent}{$x$}}
          \EndIf
        \ElsIf{$s$ is black $\land$ \Call{Left}{$s$} is red}
          \Comment{兄弟为黑，一个侄子为红}
          \State ...
        \EndIf
    \EndIf
  \EndWhile
\EndFunction
\end{algorithmic}

\subsection{双重黑色节点的兄弟节点为黑色，该兄弟节点的两个子节点也全是黑色。}
这种情况下，我们可以将这个兄弟节点染成红色，将双重黑色变回黑色，然后将双重黑色属性向上传递一层到父节点。如图\ref{fig:del-case3}所示，有两种对称的情况。

\begin{figure}[htbp]
  \centering
  \setlength{\unitlength}{1cm}
  \begin{picture}(10, 4)
  \put(5, 2){$\Rightarrow$}
  \subfloat[$x$的颜色为红或者黑。]{\includegraphics[scale=0.4]{../../../datastruct/tree/red-black-tree/img/case2-a.ps}}
  \subfloat[若$x$此前的颜色为红，将其变为黑色，否则变为双重黑色。]{\includegraphics[scale=0.4]{../../../datastruct/tree/red-black-tree/img/case2-a1.ps}}
  \end{picture}
  \\
  \begin{picture}(10, 5)
  \put(5, 2){$\Rightarrow$}
  \subfloat[$y$的颜色为红或者黑。]{\includegraphics[scale=0.4]{../../../datastruct/tree/red-black-tree/img/case2-b.ps}}
  \subfloat[若$y$此前的颜色为红，将其变为黑色，否则变为双重黑色。]{\includegraphics[scale=0.4]{../../../datastruct/tree/red-black-tree/img/case2-b1.ps}}
  \end{picture}
  \\
  \begin{picture}(1, 0.5)\end{picture} %pad
  \caption{将双重黑色向上传递} \label{fig:del-case3}
\end{figure}

上述三种情况中，双重黑色节点的兄弟节点都不为空。如果其兄弟节点为空，我们可以直接将双重黑色恢复为普通黑色，然后将黑色向上传递。如果双重黑色最终向上传递到根节点，我们可以将根节点变为普通黑色节点，从而结束修复过程。另外，如果双重黑色在修复过程中被重新染色为普通节点，我们也可以终止。最后，我们需要一个额外处理，即如果最终的双重黑色节点是一个双重黑色空节点，我们需要将其恢复为普通空节点。最终的算法如下所示。

\begin{algorithmic}[1]
\Function{Delete-Fix}{$T$, $x$, $f$}
  \State $n \gets$ NIL
  \If{$f$ = True}  \Comment{$x$是一个双重黑色NIL节点}
    \State $n \gets x$
  \EndIf
  \If{$x$ = NIL} \Comment{将只有一个叶子节点的树删空}
    \State \Return NIL
  \EndIf
  \While{$x \neq T \lor$ \Call{Color}{$x$} $= \mathcal{B}^2$}
    \Comment{$x$ isn't root or $x$ isn't doubly black}
    \If{\Call{Sibling}{$x$} $\neq$ NIL} \Comment{双重黑色节点的兄弟节点不为空}
        \State $s \gets$ \Call{Sibling}{$x$}
        \If{$s$ is red} \Comment{兄弟为红色}
          \State set \Call{Parent}{$x$} red
          \State set $s$ black
          \If{$x = $ \textproc{Left}(\Call{Parent}{$x$})} \Comment{$x$为其父的左孩子}
            \State $T \gets$ \textproc{Rotate-Left}{$T$, \Call{Parent}{$x$}}
          \Else \Comment{$x$为其父的右孩子}
            \State $T \gets$ \textproc{Rotate-Right}{$T$, \Call{Parent}{$x$}}
          \EndIf
        \ElsIf{$s$ is black $\land$ \Call{Left}{$s$} is red}
          \Comment{兄弟为黑，一个侄子为红}
          \If{$x = $ \textproc{Left}(\Call{Parent}{$x$})}
            \Comment{双重黑色节点是其父的左孩子}
            \State set $x$, \Call{Parent}{$x$}, and \Call{Left}{$s$} all black
            \State $T \gets$ \Call{Rotate-Right}{$T$, $s$}
            \State $T \gets$ \textproc{Rotate-Left}($T$, \Call{Parent}{$x$})
          \Else \Comment{双重黑色节点是其父的右孩子}
            \State set $x$, \Call{Parent}{$x$}, $s$, and \Call{Left}{$s$} all black
            \State $T \gets$ \textproc{Rotate-Right}($T$, \Call{Parent}{$x$})
          \EndIf
        \ElsIf{$s$ is black $\land$ \Call{Right}{$s$} is red}
          \If{$x = $ \textproc{Left}(\Call{Parent}{$x$})}
            \State set $x$, \Call{Parent}{$x$}, $s$, and \Call{Right}{$s$} all black
            \State $T \gets$ \textproc{Rotate-Left}($T$, \Call{Parent}{$x$})
          \Else
            \State set $x$, \Call{Parent}{$x$}, and \Call{Right}{$s$} all black
            \State $T \gets$ \Call{Rotate-Left}{$T$, $s$}
            \State $T \gets$ \textproc{Rotate-Right}($T$, \Call{Parent}{$x$})
          \EndIf
        \State ...
        \EndIf
    \EndIf
  \EndWhile
\EndFunction
\end{algorithmic}

综合公式（\ref{eq:db-case-1a}）、（\ref{eq:db-case-2}）和（\ref{eq:db-case-3a}），我们可以得到最终的Haskell删除程序。

\begin{lstlisting}[style=Haskell]
-- 兄弟节点为黑色，并且有一个红色子节点
fixDB color a@(Node BB _ _ _) x (Node B (Node R b y c) z d)
      = Node color (Node B (makeBlack a) x b) y (Node B c z d)
fixDB color BBEmpty x (Node B (Node R b y c) z d)
      = Node color (Node B Empty x b) y (Node B c z d)
fixDB color a@(Node BB _ _ _) x (Node B b y (Node R c z d))
      = Node color (Node B (makeBlack a) x b) y (Node B c z d)
fixDB color BBEmpty x (Node B b y (Node R c z d))
      = Node color (Node B Empty x b) y (Node B c z d)
fixDB color (Node B a x (Node R b y c)) z d@(Node BB _ _ _)
      = Node color (Node B a x b) y (Node B c z (makeBlack d))
fixDB color (Node B a x (Node R b y c)) z BBEmpty
      = Node color (Node B a x b) y (Node B c z Empty)
fixDB color (Node B (Node R a x b) y c) z d@(Node BB _ _ _)
      = Node color (Node B a x b) y (Node B c z (makeBlack d))
fixDB color (Node B (Node R a x b) y c) z BBEmpty
      = Node color (Node B a x b) y (Node B c z Empty)
-- 兄弟节点是红色
fixDB B a@(Node BB _ _ _) x (Node R b y c) = fixDB B (fixDB R a x b) y c
fixDB B a@BBEmpty x (Node R b y c) = fixDB B (fixDB R a x b) y c
fixDB B (Node R a x b) y c@(Node BB _ _ _) = fixDB B a x (fixDB R b y c)
fixDB B (Node R a x b) y c@BBEmpty = fixDB B a x (fixDB R b y c)
-- 兄弟节点和它的两个子节点都是黑色，向上传递黑色
fixDB color a@(Node BB _ _ _) x (Node B b y c) = makeBlack (Node color (makeBlack a) x (Node R b y c))
fixDB color BBEmpty x (Node B b y c) = makeBlack (Node color Empty x (Node R b y c))
fixDB color (Node B a x b) y c@(Node BB _ _ _) = makeBlack (Node color (Node R a x b) y (makeBlack c))
fixDB color (Node B a x b) y BBEmpty = makeBlack (Node color (Node R a x b) y Empty)
-- 其他情况
fixDB color l k r = Node color l k r
\end{lstlisting}

对于含有$n$个节点的红黑树，删除算法的复杂度为$O(\lg n)$。

\begin{Exercise}

\begin{itemize}
\item 选用一种编程语言，实现本节提到的“标记――重建”删除算法：也就是先将要删除的节点标记，但不进行真正的删除。当被标记的节点数目超过50\%的时候，用全部未标记的节点重建树。
\item 为什么不需要在$mkBlk$的调用处，显示地再调用$fixBlack^2$?
\end{itemize}

\end{Exercise}

\ifx\wholebook\relax \else
\begin{thebibliography}{99}

\bibitem{CLRS}
Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest and Clifford Stein.
``Introduction to Algorithms, Second Edition''. ISBN:0262032937. The MIT Press. 2001 （《算法导论》中文版）

\end{thebibliography}

\end{document}
\fi
